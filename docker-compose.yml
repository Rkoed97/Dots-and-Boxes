version: "3.9"

services:
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: dots
      POSTGRES_USER: dots
      POSTGRES_PASSWORD: dots_change_me
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U dots -d dots"]
      interval: 10s
      timeout: 5s
      retries: 5
    volumes:
      - ./docker-data/postgres:/var/lib/postgresql/data
    networks:
      - internal

  pgadmin:
    image: dpage/pgadmin4:latest
    depends_on:
      db:
        condition: service_healthy

    # Keep it private to the host; expose via Apache only if you add auth/IP allowlisting
    ports:
      - "127.0.0.1:5050:80"

    environment:
      # Admin login for pgAdmin UI
      PGADMIN_DEFAULT_EMAIL: admin@deskbuddy.cc
      PGADMIN_DEFAULT_PASSWORD: change_me_now_to_a_strong_password

      # Hardened settings
      PGADMIN_CONFIG_SERVER_MODE: "True"
      PGADMIN_CONFIG_MASTER_PASSWORD_REQUIRED: "True"
      PGADMIN_CONFIG_ENHANCED_COOKIE_PROTECTION: "True"
      PGADMIN_CONFIG_COOKIE_CSRF_PROTECT: "True"
      PGADMIN_CONFIG_WTF_CSRF_CHECK_DEFAULT: "True"
      PGADMIN_CONFIG_SESSION_COOKIE_HTTPONLY: "True"

      # If/when you put pgAdmin behind HTTPS (recommended), set this to True
      # (leave False if you only access via http://127.0.0.1:5050)
      PGADMIN_CONFIG_SESSION_COOKIE_SECURE: "False"

      # Optional: reduce info leakage
      PGADMIN_CONFIG_CONSOLE_LOG_LEVEL: "30"

    volumes:
      # Persistent pgAdmin state
      - ./docker-data/pgadmin:/var/lib/pgadmin

      # Auto-provisioning: registered servers + password file
      - ./docker-data/pgadmin-provisioning/servers.json:/pgadmin4/servers.json:ro
      - ./docker-data/pgadmin-provisioning/pgpass:/pgadmin4/pgpass:ro

    networks:
      - internal


  api:
    build:
      context: .
      dockerfile: apps/api/Dockerfile
    environment:
      NODE_ENV: production
      PORT: "3001"
      DATABASE_URL: postgresql://dots:dots_change_me@db:5432/dots
      CORS_ORIGIN: http://localhost:3000
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "127.0.0.1:3001:3001"
    healthcheck:
      test: ["CMD", "node", "-e", "fetch('http://localhost:'+ (process.env.PORT||3001) +'/api/health').then(r=>{if(!r.ok)process.exit(1)}).catch(()=>process.exit(1))"]
      interval: 20s
      timeout: 5s
      retries: 5
    networks:
      - internal

  web:
    build:
      context: .
      dockerfile: apps/web/Dockerfile
    environment:
      NODE_ENV: production
      PORT: "3000"
      NEXT_PUBLIC_API_BASE: /api
      NEXT_PUBLIC_WS_PATH: /ws
    depends_on:
      api:
        condition: service_healthy
    ports:
      - "127.0.0.1:3000:3000"
    healthcheck:
      test: ["CMD", "node", "-e", "fetch('http://localhost:'+ (process.env.PORT||3000) +'/').then(r=>{if(!r.ok)process.exit(1)}).catch(()=>process.exit(1))"]
      interval: 20s
      timeout: 5s
      retries: 5
    networks:
      - internal

networks:
  internal:
